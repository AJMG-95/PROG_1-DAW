1. Al evaluar la expresi√≥n 2 < 1 or 2 != 1, el resultado es:
a. 1.
b. 2.
c. True.
d. False.


2. ¬øQu√© instrucci√≥n es equivalente a i += 1?
a. i = i + 1.
b. i + 1.
c. 1 += i.
d. i = i + i.


3. ¬øQu√© valor devuelve la siguiente expresi√≥n: 3 if 1 < 2 else 4?
a. 1.
b. 2.
c. 3.
d. 4.


4. Selecciona la expresi√≥n cuya evaluaci√≥n resulta 3:
a. 3 + 2 * 6 / 5.
b. (3 + 2) * 6 / 5.
c. (3 + 2 * 6) / 5.
d. 3 + 2 * (6 / 5).


5. Los operadores l√≥gicos operan con valores booleanos, resultando:
a. Valores enteros.
b. Valores enteros y booleanos.
c. Otros tipos de valores.
d. S√≥lo valores booleanos.


6. La evaluaci√≥n de una operaci√≥n relacional puede generar un valor de tipo:
a. Entero.
b. Real.
c. Booleano.
d. Todos los anteriores.


7. La expresi√≥n 3 == 3 and 2 < 3 and 1 != 2 devuelve:
a. True.
b. False.
c. No se puede evaluar.
d. No genera un booleano, ya que la expresi√≥n es aritm√©tica.


8. La siguiente expresi√≥n, donde interviene la variable booleana a:
3 != 3 or a or 1 < 2
resulta:
a. Depender√° del valor de a.
b. True.
c. False.
d. No se puede evaluar.


9. Elige los valores de las variables enteras (a, b y c) que permiten que la evaluaci√≥n de la
siguiente expresi√≥n sea cierta: a < b and b != c and b <= c:
a. a = 1, b = 1, c = 2.
b. a = 2, b = 1, c = 2.
c. a = 1, b = 2, c = 2.
d. a = 1, b = 2, c = 3.
10. El bloque de instrucciones de una sentencia if se ejecutar√°:
a. Siempre.
b. Nunca.
c. Depender√° de la evaluaci√≥n de la expresi√≥n utilizada.
d. Todas las respuestas anteriores son correctas.


11. En una sentencia if-else, los bloques de instrucciones (bloque True y bloque False)
pueden ejecutarse:
a. Simult√°neamente.
b. Es posible, dependiendo de la condici√≥n utilizada, que no se ejecute ninguno.
c. Siempre se ejecutar√° al menos uno y son excluyentes.
d. Todas las anteriores son incorrectas.


12. La instrucci√≥n que permite detener completamente las iteraciones de un bucle, es:
a. stop.
b. break.
c. continue.
d. finish.


13. La instrucci√≥n que permite detener la iteraci√≥n actual de un bucle, continuando con la
siguiente (si procede) es:
a. stop.
b. break.
c. continue.
d. finish.


14. ¬øCu√°ntas veces se ejecutar√° la instrucci√≥n del bucle m√°s interno en el siguiente frag-
mento de c√≥digo?
for i in range(1, 11):
for i in range(1, 6):
print("Hola")
a. 10 veces.
b. 5 veces.
c. 50 veces.
d. Infinitas veces.


15. Analiza el siguiente c√≥digo y busca qu√© valores de a y b implican un menor n√∫mero de
iteraciones:
for i in range(a, a + b + 1):
for j in range(a + b, -1, -1):
...
a. a = 1 y b = 3.
b. a = 3 y b = 1.
c. a = 1 y b = 1.
d. a = 3 y b = 3.
16. Una variable que se crea dentro de un √°mbito s√≥lo se podr√° utilizar:
a. En cualquier parte del programa.
b. En todos los bucles.
c. Dentro del √°mbito donde se ha creado.
d. Todas las opciones anteriores son correctas.


17. Una variable que se crea dentro de una funci√≥n s√≥lo se podr√° utilizar:
a. En cualquier lugar del c√≥digo.
b. Fuera de cualquier funci√≥n.
c. S√≥lo en la funci√≥n donde se ha creado.
d. Ninguna de las opciones anteriores es correcta.


18. ¬øQu√© instrucci√≥n permite a una funci√≥n imperativa devolver un valor?
a. value.
b. return.
c. def.
d. =.


19. El tipo devuelto por todas las funciones definidas en nuestro programa tiene que ser
siempre:
a. int.
b. float.
c. bool.
d. Ninguna de las opciones anteriores es correcta.


20. El paso de argumentos a una funci√≥n en Python siempre es:
a. Por valor.
b. Por copia.
c. Por asignaci√≥n.
d. Por referencia.


21. ¬øCu√°les de las siguientes operaciones se pueden implementar f√°cilmente mediante
funciones recursivas?
a. ùëéùëõ = ùëé ¬∑ ùëéùëõ‚àí1.
b. ùëíùë†_ùëùùëéùëü (ùëõ) = ùëíùë†_ùëñùëöùëùùëéùëü (ùëõ ‚àí 1) y ùëíùë†_ùëñùëöùëùùëéùëü (ùëõ) = ùëíùë†_ùëùùëéùëü (ùëõ ‚àí 1).
c. ùë†ùë¢ùëöùëé(ùëé, ùëè) = ùë†ùë¢ùëöùëé(ùëé + 1, ùëè ‚àí 1).
d. Todas las anteriores respuestas son correctas.


22. En los identificadores de las funciones en Python, al igual que en los de las variables, el
convenio a usar es:
a. Snake case: suma_notas_alumnos.
b. Todo junto en min√∫sculas: sumanotasalumnos.
c. Pascal case: SumaNotasAlumnos.
d. Camel case: sumaNotaAlumnos.

22. En los identificadores de las funciones en Python, al igual que en los de las variables, el
convenio a usar es:
a. Snake case: suma_notas_alumnos.
b. Todo junto en min√∫sculas: sumanotasalumnos.
c. Pascal case: SumaNotasAlumnos.
d. Camel case: sumaNotaAlumnos.
Soluci√≥n: a.
23. En Python, una lista puede almacenar datos de distintos tipos, como por ejemplo enteros,
booleanos, reales, etc.
a. Cierto, las listas siempre pueden almacenar datos de distintos tipos.
b. Falso, las listas s√≥lo pueden almacenar datos de un √∫nico tipo.
c. Pueden almacenar datos de distintos tipos siempre que sean num√©ricos.
d. Pueden almacenar datos de distintos tipos siempre que la longitud de los datos
sea id√©ntica.
Soluci√≥n: a.
24. En Python, la numeraci√≥n de los √≠ndices que determina la identificaci√≥n de cada elemento
de una lista comienza en:
a. Cero.
b. Uno.
c. Depende del tipo de dato de la lista.
d. Es configurable por el usuario.
Soluci√≥n: a.
25. Si en una lista de 10 elementos intentamos acceder al elemento con √≠ndice 11 (que se
encuentra fuera de rango):
a. Al salirse del rango de la longitud, Python redimensiona la lista de forma autom√°-
tica.
b. No es posible y lanza una excepci√≥n.
c. Los √≠ndices tienen un comportamiento circular y utilizar el √≠ndice 11 es equivalente
a utilizar el √≠ndice 1.
d. Ninguna de las anteriores respuestas es correcta.
Soluci√≥n: b.
26. La forma de conocer la longitud de una lista l es mediante:
a. l.size.
b. len(l).
c. l.len.
d. List.size(l).
Soluci√≥n: b.
27. En Python, al igual que en otros muchos lenguajes de programaci√≥n, las secuencias de
escape se escriben mediante:
a. Dos puntos (:).
b. El car√°cter u may√∫scula (U).
c. El car√°cter u min√∫scula (u).
d. Una barra invertida (\).
Soluci√≥n: d.
28. Se√±ala qu√© opci√≥n es cierta en Python:
a. 'a' es una cadena de caracteres.
b. "a" es una cadena de caracteres.
c. """a""" es una cadena de caracteres.
d. Todas las opciones anteriores son ciertas.
Soluci√≥n: d.
29. La forma de extraer en Python el cuarto car√°cter de la cadena almacenada en la variable
cad es:
a. cad.index(4).
b. cad.get(4).
c. cad[3].
d. cad.char(3).
Soluci√≥n: c.
30. El m√©todo que permite eliminar los caracteres blancos del principio y el final de una
cadena es:
31. ¬øQu√© m√©todo permite convertir una lista de cadenas (por ejemplo, ['ab', 'cd', 'ef'])
en una cadena formada por la concatenaci√≥n de los elementos de la cadena (en este
caso, 'abcdef')?
a. join.
b. concat.
c. str.
d. split.
Soluci√≥n:
32. ¬øCu√°l de los siguientes modos de apertura de archivos se debe usar para abrir un archivo
de texto en s√≥lo lectura?
a. r+.
b. wb.
c. a.
d. r.
Soluci√≥n: d.
33. ¬øCu√°l de las siguientes preguntas es correcta?
a. Escribir en un archivo supone siempre hacer crecer el tama√±o del archivo.
b. A√±adir a un archivo supone siempre hacer crecer el tama√±o del archivo.
c. Para leer de un archivo primero tiene que estar cerrado.
d. Siempre que se escribe en un archivo, si no existe, lo crea.
Soluci√≥n: b.
34. ¬øCu√°l es la primera acci√≥n que se debe realizar sobre un archivo?
a. Guardarlo.
b. Cerrarlo.
c. Abrirlo.
d. Escribirlo.
Soluci√≥n: c.
35. ¬øCu√°l es la √∫ltima acci√≥n que se debe realizar sobre un archivo?
a. Guardarlo.
b. Cerrarlo.
c. Abrirlo.
d. Escribirlo.
Soluci√≥n: b.
36. ¬øCu√°l es el tipo de los datos le√≠dos desde un archivo de texto?
a. Booleanos.
b. Enteros.
c. Cadenas.
d. Reales.
Soluci√≥n: c.
37. ¬øCu√°les de las siguientes afirmaciones son correctas respecto a los modos de apertura
de un archivo? (Se pueden se√±alar varias)
a. Cuando se abre un archivo s√≥lo para lectura, si el archivo no existe, se produce un
error.
b. Cuando se abre un archivo s√≥lo para escritura, si el archivo no existe, se produce
un error.
c. Cuando se abre un archivo s√≥lo para lectura, si el archivo no existe, el programa
abrir√° un archivo vac√≠o.
d. Cuando se abre un archivo s√≥lo para escritura, si el archivo no existe, se crear√° un
archivo nuevo.
e. Cuando se abre un archivo s√≥lo para escritura, si el archivo existe, se sobreescribir√°
con un archivo nuevo.
Soluci√≥n: a, d, e.
38. ¬øCu√°l de las siguientes instrucciones permiten obtener el contenido completo de un
archivo en forma de cadena?
a. f.read(n)
b. f.read()
c. f.readline()
d. f.readlines()
Soluci√≥n: b.
39. Una excepci√≥n en Python:
a. Se produce cuando se rompe el monitor del ordenador.
b. Es un valor √∫nico de una variable.
c. Se lanza cuando se produce una condici√≥n an√≥mala durante la ejecuci√≥n de un
programa.
d. Tiene lugar cuando un c√≥digo es sint√°cticamente incorrecto.
Soluci√≥n: c.
40. La palabra reservada finally:
a. Termina la ejecuci√≥n de un programa.
b. Termina la ejecuci√≥n de una funci√≥n, forzando el return.
c. En una estructura try ... except, fuerza la ejecuci√≥n de su bloque antes de que
se ejecute una sentencia return e independientemente de si se produce o no una
excepci√≥n.
d. Indica el final de una funci√≥n.
Soluci√≥n: c.
41. Nos tenemos que asegurar de que todos los flujos abiertos deben cerrarse antes de que
termine el programa. . .
a. Porque se quedar√≠an abiertos hasta que se apague el ordenador.
b. Porque otro programa podr√≠a alterarlos.
c. Porque se deben liberar los recursos asociados, como los archivos. Adem√°s, podr√≠an
quedar caracteres del b√∫fer sin escribir.
d. Porque se pueden borrar datos de una archivo.
Soluci√≥n: c.
42. Los flujos se cierran:
a. Con el m√©todo close.
b. Apagando el ordenador.
c. Abortando el programa.
d. Con el atributo closed.
Soluci√≥n: a.
43. Los gestores de contexto:
a. Permiten abrir flujos asociados con varios archivos a la vez.
b. Es abrir archivos recurrendo a una lista.
c. Consiste en abrir flujos sin peligro de que se produzcan excepciones.
d. Permiten gestionar autom√°ticamente lo que ocurre al entrar o salir de un bloque
de c√≥digo, y se pueden usar junto con la orden with para asegurar el cierre de un
archivo previamente abierto al ejecutar el with.
Soluci√≥n: d.
44. ¬øDe qu√© forma podemos importar el m√≥dulo ElementTree para manipular documentos
XML?
a. import xml.etree.ElementTree as ET
b. import xml.etree.ElementTree
c. Ambas respuestas son correctas.
d. Ninguna respuesta es correcta.
Soluci√≥n: c.
45. Dado el siguiente documento XML:
<?xml version="1.0"?>
<club>
<nombre>Di√≥genes</nombre>
<socios>
<socio id="1">
<nombre>Sherlock Holmes</nombre>
<direccion>221B Baker St</direccion>
<alta>1890-12-14</alta>
</socio>
<socio id="51">
<nombre>Winston Churchill</nombre>
<direccion>10 Downing St</direccion>
<alta>1942-02-13</alta>
</socio>
</socios>
</club>
y suponiendo que la variable raiz (de tipo Element) contiene el nodo ra√≠z del √°rbol
correspondiente a dicho documento, ¬øqu√© expresi√≥n nos devuelve una lista con los
nodos <nombre> de todos los socios del club?
a. raiz.findall('.//nombre').
b. raiz.findall('socios/*/nombre').
c. raiz.iter('nombre').
d. raiz.find('nombre').
Soluci√≥n: b.
46. Siendo socio un nodo <socio> del documento XML del ejercicio anterior (es decir, una
variable de tipo Element), ¬øqu√© expresi√≥n nos devuelve el nombre del socio en forma
de cadena?
a. socio.find('nombre').text
b. socio.findall('nombre').text
c. socio.find('nombre')
d. socio.nombre
Soluci√≥n: a
